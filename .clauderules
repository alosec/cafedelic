# Cafedelic Project Intelligence

## Project Philosophy
- **Austere minimalism**: Prefer inconvenience from refusing complexity over complexity itself
- **Intelligence over control**: We provide understanding, not manipulation
- **High-level abstractions only**: No low-level tmux/pane management

## Key Discoveries

### What Cafedelic IS
- A development intelligence framework
- A context analysis engine  
- A translator of opaque logs into human understanding
- An accumulator of project knowledge over time

### What Cafedelic IS NOT
- A tmux manager
- A layout tool
- A terminal launcher
- A low-level pane controller

## Architecture Patterns

### Separation of Concerns
- Cafedelic = Intelligence layer
- User's tmux = Display/layout layer
- Desktop Commander = Action layer
- MCP tools = Query interface

### Implementation Approach
- Start with proven simple solutions (bash scripts, Node.js)
- Avoid complex frameworks (learned from teemax)
- Event-driven architecture with loose coupling
- Template-based translations for maintainability

## Technical Decisions

### Core Stack
- Express.js server (minimal overhead)
- Chokidar for file watching (proven reliability)
- TypeScript for type safety
- No tmux dependencies

### Service Pattern
```typescript
// Each service has single responsibility
WatcherService    // Only watches files
TranslatorService // Only translates logs  
ActivityStore     // Only stores activities
```

## Real-World Usage Insights

### First Live Test (2025-05-25)
Monitoring actual Claude Desktop usage revealed:
- `read_multiple_files` is a common pattern for exploration
- File paths are embedded in args.paths array
- Real-time monitoring creates powerful visibility

Example output that sparked Emacs integration idea:
```
[7:09pm] Claude is exploring ~/code/teemax/memory-bank
[7:10pm] Claude used read_multiple_files
[7:10pm] Claude is reading .clauderules
```

### Emacs Integration Opportunity
The "hello world" success (log → transformation → display) opens the door for active coordination:
- Watch what files Claude accesses
- Automatically open them in Emacs
- Create synchronized development environment
- Build foundation for future caching/SQLite

## DC Log Intelligence

### Log Location
`~/.claude-server-commander/claude_tool_call.log`

### Log Format (Discovered)
Pipe-delimited format with **tab characters**: `TIMESTAMP | COMMAND \t| Arguments: JSON`
Example: `2025-05-26T19:20:59.401Z | list_directory      \t| Arguments: {"path":"/home/alex"}`

**CRITICAL**: Tab characters appear between command and arguments separator - must use regex parsing, not simple split.

### Common Commands to Translate
- read_file → "Claude is reading [filename]"
- write_file → "Claude is updating [filename]"
- execute_command → "Claude executed: [command]"
- search_code → "Claude searched for [pattern]"
- **list_directory** → "Claude is exploring [path]" (fixed parsing 2025-05-26)

### Translation Philosophy
Make the activity human-readable and meaningful, not just technically accurate.

## Future Vision

### Phase 1 (Current) ✅
DC log watching and translation - make Claude's actions visible

### Phase 2 (Output Routing System - Issue #4)
Replace hard-coded tmux destinations with flexible routing management:
- Dynamic source → destination assignment
- Emacs daemon lifecycle management  
- Runtime configuration without code changes
- Support for multiple sources and destinations

### Phase 3 (Intelligence Layer)
Pattern analysis - understand workflows and development patterns

### Phase 4 (Knowledge Accumulation)
Intelligence accumulation - build project knowledge over time

## Lessons from Related Projects

### From Teemax
- Simple Node.js scripts beat complex TypeScript servers
- Real-time log following with position tracking works well
- Human-readable translations are highly valuable

### From Deli
- Named pane abstractions are useful but too low-level for cafedelic
- MCP tool integration patterns work well
- Focus on specific value proposition

## Remember
When in doubt, choose simplicity and clarity over feature completeness. Cafedelic's value is in making development transparent and understandable, not in controlling tools.


## Layout Solution Discovered (2025-05-26)

After exploring tmex extensively, found the ideal IDE layout:
- Use `tmex 131 --transpose` for consistent 5-pane structure
- Set pane names with `@pane_name` user options
- Reference panes: `tmux display -p -t '@pane_name=cafedelic-editor' '#{pane_id}'`
- File tree lives in tmux pane 1, not in emacs

Layout structure:
```
┌─────────────────────────────┐
│      Activity Monitor       │
├──────┬──────────┬──────────┤
│ Tree │  Editor  │ Terminal │
├──────┴──────────┴──────────┤
│        DC Logs              │
└─────────────────────────────┘
```

This provides predictable pane IDs (0-4) that can be named and targeted reliably.

**Emacs Output Routing (Fixed 2025-05-26)**:
- Route emacsclient output to session 9:0.2 using `tmux run-shell`
- Provides visibility into file/directory opening actions
- Falls back gracefully if target pane doesn't exist

## State Management Architecture (2025-05-26)

Implemented event-sourced state management:
- SQLite3 for persistence (no external dependencies)
- StateManager as central event hub
- Services communicate via events, not direct calls
- Database is source of truth, memory is cache

Key pattern:
```
DC Logs → WatcherService → StateManager → Database
                ↓              ↓
         TranslatorService   Events → UI Updates
```

## Small Testable Components Philosophy

Build from small, individually testable pieces:
- Each service has single responsibility
- Services extend EventEmitter for loose coupling
- Tools are simple wrappers around shell commands
- Database operations are isolated in PersistenceService

This approach creates maintainable, debuggable systems.
